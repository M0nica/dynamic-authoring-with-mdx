<SlidePage>

<Cover>

# Dynamic Authoring with MDX üìù

Monica Powell &bull; Apollo Day &bull; November 2020

</Cover>

---

# Hi, I'm Monica üëãüèæ

I'm a software engineer who is passionate about making contributing to open-source more approachable, creating technology to elevate people, and building community. I am looking forward to sharing how you can super-charge content creation with MDX.

<img
  style={{ maxWidth: "20%", textAlign: "center", display: "inline" }}
  src="/animonica.png"
/>

<SpeakerNotes>
  {" "}
  I'm Monica! I'm a software engineer and community organizer. I'm passionate
  about making technology, like open-source, more accessible and created a
  Meetup group, React Ladies for women and non-binary react developers.
</SpeakerNotes>

---

# What is MDX?

Markdown + JSX

---

# What is MDX?

- "JSX in Markdown for ambitious projects"
- MDX can refer to either the syntax _or_ library
- MDX (library) converts MDX syntax -> JSX
- JSX is compiled by Babel/Webpack for browser

---

# Why MDX?

- Great authoring experience for developers
- allows React components to be imported
- to create more engaging and interactive content with the ease of markdown

<SpeakerNotes>
  I consider my personal site my personal playground and was intrigued by MDX
  and thought why not upgrade to MDX? I was hearing other developers talk about
  the superpowers of MDX and wanted to check it out for myself. I was especially
  interested in creating engaging and interactive content and had seen fun
  examples of content that resonated with me that used MDX.
</SpeakerNotes>

---

# Using MDX with Storybook

## https://storybook.js.org/docs/react/writing-docs/mdx

# Example: Timer

Add a timer or a countdown into a markdown file with the following:

`<CountDown minutes="1" seconds="30" />`

## <CountDown minutes="1" seconds="30" />

---

# Example: Embed

`<CodePen codePenId="jObpJma" tabs={["css", "result"]} />`

<CodePen codePenId="jObpJma" tabs={["css", "result"]} />

_Above embed powered by `gatsby-mdx-embed`_.

<SpeakerNotes>
  For example here within an article written in Markdown I used an embed plugin
  to display a Codepen pen
</SpeakerNotes>

---

# What have I done with MDX so far...

- ‚ú® Upgraded ‚ú® components for code snippets
- ‚ú® Upgraded ‚ú® table of contents
- created Callout components to complement markdown quotes
- created a dynamic slider

<SpeakerNotes>
  After the issue retrieving MDX data was resolved it was time to get started
  with actually using MDX on my site! Some of the ways I've used MDX so far is
  to upgrade code snippets to use more customizable JSX instead of markdown,
  dynamic table of contents, added Callout components and added a dynamic slider
  to a post.
</SpeakerNotes>

---

How to use MDX

- wrap code in <MDXProvider/>

```js
// src/App.js
import React from "react";
import { MDXProvider } from "@mdx-js/react";
import {
  LoadingSpinner,
  SignUp,
  TableOfContents,
  Callout,
  Code,
} from "./components";

const components = {
  LoadingSpinner,
  Signup,
  TableOfContents,
  Callout,
  pre: Code, // override markdown styling
};

export default (props) => (
  <MDXProvider components={components}>
    <main {...props} />
  </MDXProvider>
);
```

---

# ArticleTemplate.jsx

```jsx
import { MDXProvider } from "@mdx-js/react";
import { MDXRenderer } from "gatsby-plugin-mdx";

const components = {
  /* stash React components to be used in MDX blog posts here! */
};

class BlogPostTemplate extends React.Component {
  render() {
    const post = this.props.data.mdx;
    if (!post) return null;

    return (
      <MDXProvider components={components}>
        <MDXRenderer>{post.body}</MDXRenderer>
      </MDXProvider>
    );
  }
}
```

<SpeakerNotes>
  The first thing I needed to do before using MDX was wrapping the MDXProvider
  around my blog post template since I wanted MDX to be available for all of my
  articles. The MDXProvider allows you to pass the components you want to be
  available to all of the pages that are within that context in one place. This
  provider wraps both my post content and the MDXRenderer. The MDXRenderer is a
  React component from the MDX Gatsby integration that takes compiled MDX
  content and renders it. It's required if your MDX content is coming from a
  GraphQL page query or StaticQuery.
</SpeakerNotes>

---

# Table of Contents Component

<img
  style={{ maxWidth: "40%", textAlign: "center" }}
  src="/table-of-contents-visual.png"
/>

<SpeakerNotes>
  For my longer articles I like to add a table of contents so that readers can
  view an overview of what to expect in a particular article.
</SpeakerNotes>

---

# TOC: Before/After MDX

<img style={{ maxWidth: "80%", textAlign: "center" }} src="/toc-diff.png" />

<SpeakerNotes>
  I liked adding these so much that I was manually writing Markdown to render
  table of contents within my articles. Here's a diff of what the Table of
  Contents for individual posts looked like before and after MDX. After
  implementing MDX, adding table of contents is just a one line reference to a
  component.
</SpeakerNotes>

---

# TableOfContents.jsx

```jsx
import "./TableOfContents.scss";
function TableOfContents({ headings }) {
  return (
    <div className="table-of-contents">
      <h2>Table of Contents</h2>
      <ul>
        {headings.items &&
          headings.items.map((item) => (
            <li key={item.url}>
              <a href={item.url}>{item.title}</a>{" "}
            </li>
          ))}
      </ul>
    </div>
  );
}
```

<SpeakerNotes>
  In order to reduce the amount of TOC that lives in an individual blog post I
  created a Table of Contents JSX component to map through all of the headers
  and display them as list items with links. There's an autolink plugin to
  ensure the anchor link exists. The headings are being passed in from the
  TableOfContents data field which has a headings attribute.
</SpeakerNotes>

---

# ArticleTemplate.jsx

```jsx
import { MDXProvider } from "@mdx-js/react";
import { MDXRenderer } from "gatsby-plugin-mdx";
import TableOfContents from "../components/TableOfContents";

const components = {
  TableOfContents,
};

class BlogPostTemplate extends React.Component {
  render() {
    const post = this.props.data.mdx;
    if (!post) return null;

    return (
      <MDXProvider components={components}>
        <MDXRenderer>{post.body}</MDXRenderer>
      </MDXProvider>
    );
  }
}
```

<SpeakerNotes>
  I then imported the new Table of Contents component into the MDX provider in
  my article template, so that this component is accessible to any blog posts. I
  also updated the post query to pass in the tableOfContents field for that post
  as a prop that can then be passed into the TableOfContents components. The
  TableOfContents field is a default available with the Gatsby MDX
  configuration. The TableOfContents field also allows you to pass in a depth to
  pull in subheadings. For my use case I only cared about the first layer but
  the TOC component can be set up to recursively render all of the headings and
  subheadings.
</SpeakerNotes>{" "}

---

# Callout Banners

<Callout>Here's some important information for you to know!</Callout>
<Callout variant="danger">Oops, there was an error</Callout>
<Callout variant="garden">
  That's all for now! ü•ï I am continuing to update this post, so check back
  later!
</Callout>
<Callout variant="book">
  "Here's a great quote from something I read recently.
</Callout>

Inspired by http://prince.dev/ üíú

<SpeakerNotes>
  Something cool I saw around the web was folks using Callout banners to make
  certain content stand out. I had a similar style already for a markdown quote
  on my blog and was eager to extend the different styles of callouts I could
  include in content so I created a Callout component.
</SpeakerNotes>

---

# Markdown Quote -> Callout.jsx

```
> Markdown quote
```

to

```jsx
<>
  <Callout>...</Callout>
  <Callout variant="danger">...</Callout>
  <Callout variant="garden">...</Callout>
  <Callout variant="book">...</Callout>
</>
```

<SpeakerNotes>
  So now in addition to being able to add quotes within blog posts, I can also
  add different variations of the banner by using the Callout component.
</SpeakerNotes>

---

# Callout Banners

<Callout>Here's some important information for you to know!</Callout>
<Callout variant="danger">Oops, there was an error</Callout>
<Callout variant="garden">
  That's all for now! ü•ï I am continuing to update this post, so check back
  later!
</Callout>
<Callout variant="book">
  "Here's a great quote from something I read recently.
</Callout>

<SpeakerNotes> Show the visual callouts again </SpeakerNotes>

---

# Callout.jsx Variants

```jsx
const variantStyles = {
  info: {
    borderLeft: "4px solid #b4aaff",
    backgroundColor: "rgba(224, 226, 255, 0.5)",
    color: "#2a2135",
  },
  danger: {
    borderLeft: "4px solid #ff7828",
    backgroundColor: "rgb(253, 236, 234)",
  },
  garden: {
    borderLeft: "4px solid #72bc23",
    backgroundColor: "rgb(249, 253, 234)",
  },
  book: {
    borderLeft: "4px solid #44a9ba",
    backgroundColor: "rgb(234, 248, 253);",
  },
};
```

<SpeakerNotes>
  For each variation there are different styles for borderLeft and
  backgroundColor that are based off of the variant that is passed in. In the
  component it also adds CSS classnames based on the variant prop.
</SpeakerNotes>

---

# Callout.jsx

```jsx
/* CSS file for pseudoclasses a.k.a emojis */
import styles from "./callout.module.scss"
export default function Callout({ variant = "info", children }) {
  const classes = `${styles.infoBox} ${styles[variant]}`;
  const variantStyles = {
    ...
  };
  return (
    <aside css={{ /* a bunch of default CSS*/ ...variantStyles[variant],
      }} className={classes} >
      {children}
    </aside>
  );
}
```

<SpeakerNotes>
  The Callout component also has a CSS Module file for the psuedoclasses to show
  the emojis before each callout based on the CSS classname that was appended
  from the variant prop.
</SpeakerNotes>

---

# Upgraded Code Snippets

- switched from `gatsby-remark-prismsjs` to `prism-react-renderer`
- more robust functionality available with React/MDX
- `prismjs` extendability limited within `gatsby-remark-prismsjs` plugin, e.g., the ability the copy to clipboard functionality.

<img
  style={{ maxWidth: "50%", textAlign: "center", display: "inline" }}
  src="/code_snippet_without_mdx.png"
/>
<img
  style={{ maxWidth: "50%", textAlign: "center", display: "inline" }}
  src="/code_snippet_with_mdx.png"
/>

<SpeakerNotes>
  I switched from gatsby-remark-prismjs to prism-react-renderer in order to have
  access to more robust functionality that is available with React/MDX. I found
  that prismsjs extendability was limited with gatsby-remark-prismjs and adding
  additional plugins to support the existing prismsjs plugins like the ability
  to copy to clipboard was under development.
</SpeakerNotes>

---

# Code.jsx

```jsx
import Highlight from "prism-react-renderer";
import theme from "prism-react-renderer/themes/palenight";

const Code = ({ codeString, language, metastring, ...props }) => {
  return (
    <Highlight code={codeString} language={language} theme={theme} {...props}>
      {({ className, style, tokens, getLineProps, getTokenProps }) =>
        // map through each token and render the line of code
      }
    </Highlight>
  );
};
```

<SpeakerNotes>
  I created a new Code component for prism-react-renderer to go through each
  line of code snippets
</SpeakerNotes>

---

# ArticleTemplate.jsx >> Using the Code component

```jsx
import TableOfContents from "../components/TableOfContents";
import Callout from "../components/Callout";
import { preToCodeBlock } from "mdx-utils";
import Code from "./code";

const components = {
  TableOfContents,
  Callout,
  pre: (preProps) => {
    const props = preToCodeBlock(preProps);
    if (props) {
      return <Code {...props} />;
    } else {
      return <pre {...preProps} />;
    }
  },
};
```

<SpeakerNotes>
  In the components that are passed into the MDXProvider. preToCodeBlock allows
  us to replace `<pre />` with out custom component and also retains any props
  that were passed in the MDX. Sources: https://mdxjs.com/blog/custom-pragma,
  https://www.christopherbiscardi.com/post/codeblocks-mdx-and-mdx-utils{" "}
</SpeakerNotes>

---

# Updating Syntax for prism-react-renderer

- syntax for code snippets varied a bit between the two plugins
- I manually searched through my code examples to make sure the syntax was updated to render properly with the updated plugin
- i.e., if there were highlighted lines the right lines were still being highlighted

---

# Summary

- Swapping from gatsby-transformer-remark for gatsby-plugin-mdx is pretty straightforward but beware of potential plugin conflicts!

- With MDX it's easier to customize posts (i.e, adding new types of Callouts, more flexible code snippets)

- Migrating to MDX has improved my developer experience

## <img style={{ maxWidth: "80%", textAlign: "center" }} src="/toc-diff.png" />

---

# Resources

- https://nickymeuleman.netlify.app/blog/table-of-contents#nested-heading-levels
- https://prince.dev/callout
- https://www.christopherbiscardi.com/post/codeblocks-mdx-and-mdx-utils

* https://github.com/PaulieScanlon/gatsby-mdx-embed
* https://github.com/frontarm/mdx-util
* https://github.com/FormidableLabs/prism-react-renderer

- https://github.com/whoisryosuke/next-mdx-deck

---

# Thank you üëãüèæ!

I need to go explore the following in MDX...

- creating examples that include React code that can be edited live üëÄ
  with Formidable's `react-live`
- Creating a dynamic countdown component
- Adding more razzle dazzle ‚ú®

</SlidePage>
